## 算法

算法 (Algorithm) 是为了解决某类问题而规定的一个有限长的操作序列。

 一个算法必须满足以下五个重要特性。 

(1)有穷性。一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。 

(2) 确定性。对千每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性， 使算法的执行者或阅读者都能明确其含义及如何执行。 

(3) 可行性。算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。

(4) 输入。一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的， 在它们被调用时，从主调函数获得输入值。 (5) 输出。一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的 算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。



一个算法的优劣应该从以下几方面来评价。 

(1)正确性。在合理的数据输入下，能够在有限的运行时间内得到正确的结果。 

(2) 可读性。一个好的算法，首先应便千人们理解和相互交流 ， 其次才是机器可执行性。可 读性强的算法有助于人们对算法的理解，而难懂的算法易千隐藏错误，且难千调试和修改。 

(3) 健壮性。当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不 会产生一些莫名其妙的输出结果。 

(4) 高效性。高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高， 可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。时 间复杂度和空间复杂度是衡量算法的两个主要指标。

## 时间复杂度和空间复杂度



### 大O表示法：

T(n)=O(f(n))

f(n)是程序运行次数和的函数，一般和循环结构次数n相关

O(),取级数，取函数的数量级：去掉常数和系数,取最大的级数

​	eg：4n²+2n+5取级数：

​	O(f(n))=O(n²)

### 常见的时间复杂度量级：

- 常数阶O(1)：无循环结构

- 对数阶O(logN)：执行的次数N和log₂n相关

  ​	

  ```c
  int i = 1;
  while(i<n)
  {
      i = i * 2;
  }
  ```

  

- 线性阶O(n)：一阶循环

- 线性对数阶O(nlogN)：将O(logN)循环n遍

  ```c
  for(m=1; m<n; m++)
  {
      i = 1;
      while(i<n)
      {
          i = i * 2;
      }
  }
  ```

  

- 平方阶O(n²)：二次循环

- 立方阶O(n³)：三次循环

- K次方阶O(n^k)：k次循环

- 指数阶(2^n)

  从上而下时间复杂度越来越大，程序的执行效率也越来越低

### 空间复杂度

S(n)=O(f(n))

O(1):算法执行所需要的临时空间不随着变量n的大小变化

```c
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

O(n):空间和变量n相关

```c
int[] m = new int[n]
```

## 线性表

主要有顺序表（数组），链表，队列，栈

### 顺序表

功能类似数组，存储相同类型的数据，在内存空间中连续存储。

数组优势：数据访问，可以直接通过下标访问到对应元素，原理：array[n]的地址=array的首地址+n*数据大小

各操作时间复杂度：

按序查找：O(1):直接取用

按值查找：O（n）（最坏情况，具体看算法）

插入或删除：O(n):每次插入或删除元素都要对后面的所有元素后移或前移，若操作的元素在开头或末尾，则需要操作n次

#### 静态顺序表的实现

```c++
//线性表-顺序表-静态顺序表
//顺序表的操作顺序是从1开始的，而对顺序表下标访问是从零开始的
#include<iostream>
using namespace std;
#define maxSize 10

typedef struct//定义静态顺序表的结构
{
    int data[maxSize];
    int length;
}SqList;

void initList(SqList &L){//初始化顺序表
    for (int i = 0; i < maxSize; i++)
    {
        L.data[i]=0;//将所有元素置零
    }
    L.length=0;//顺序表长度置零
}

void printList(SqList &L){//输出
    cout<<"输出元素:"<<endl;
    for (int i = 0; i < L.length; i++)
    {
        cout<<L.data[i]<<" ";
    }
    cout<<endl;
}

void listInsert(SqList &L,int i,int e){//插入,i:待出入位置，e待插入元素
    if(i<1||i>L.length+1){
        cout<<"插入位置无效"<<endl;//判断位置有效性
        return;//void类型时，直接return退出函数
    }
    if(L.length>=maxSize){
        cout<<"存储空间已满"<<endl;//判断空间余量
        return;
    }
    for (int j = L.length; j>=i; j--)//将第i个元素之后的元素后移
    {
        L.data[j]=L.data[j-1];
    }
    L.data[i-1]=e;
    L.length++;
}

void listDelete(SqList &L,int i,int &e){//删除第i个元素，并记录其值
    if(i<1||i>L.length){
        cout<<"删除位置无效"<<endl;//判断位置
        return;
    }
    e=L.data[i-1];//记录被删除元素的值
    for (int j = i; j < L.length; j++)
    {
        L.data[j-1]=L.data[j];//i元素后所有元素前移
    }
    L.length--;
    
}

void locateElem(SqList &L,int e){//按值查找
    int i=0;
    for ( i = 0; i < L.length; i++)
    {
        if(L.data[i]==e){
            cout<<"元素"<<e<<"在第"<<i+1<<"位"<<endl;
            return;
        }
           
    }
    cout<<"未查到该元素"<<endl;
    
}

void getElem(SqList L,int i){
    if(i<1||i>L.length){
        cout<<"查找范围无效"<<endl;
        return;
    }
    cout<<"第"<<i<<"个元素为"<<L.data[i-1]<<endl;
}
int main(){
    SqList L;
    initList(L);
    listInsert(L,1,2);
    listInsert(L,2,5);
    listInsert(L,3,9);
    listInsert(L,2,4);
    printList(L);
    locateElem(L,9);
    getElem(L,5);
}
```

#### 动态顺序表

本质是在结构体中存储一个指针，当容量不足时，申请新的空间，把旧的移到新区就行了

```c
//线性表-顺序表-动态顺序表
#include<iostream>
using namespace std;
#define initSize 3//设置初始大小3

typedef struct{//==定义动态顺序表结构==
    int *data;//用指针操作
    int maxSize;
    int length;
}SeqList;

void initList(SeqList &L){//==初始化==
    L.data=(int *)malloc(initSize * sizeof(int));//动态分配内存，并转为int指针
    L.length=0;
    L.maxSize=initSize;
}

void printList(SeqList &L){//==输出顺序表==
    cout<<"输出顺序表:"<<endl;
    for (int i = 0; i < L.length; i++)
    {
        cout<<L.data[i]<<" ";//指针也可以用[i]下标表示距离指针位置i个单位的地址
    }
    cout<<endl;
}

void increaseSize(SeqList &L,int len){//==动态增加长度==
    int *p=L.data;//先将旧空间首地址存下来
    L.data=new int[L.maxSize + len];//申请新的空间
    for (int i = 0; i < L.length; i++)
    {
        L.data[i]=p[i];//将旧空间的元素转移到新空间
    }
    L.maxSize+=len;
    delete p;//new出来的用过后要delete，避免内存泄漏
    return;
}

void listInsert(SeqList &L,int i,int e){//==插入==
    if(i<1||i>L.length+1){
        cout<<"插入范围无效"<<endl;//判断范围
        return;
    }
    if(L.length>=L.maxSize){
       increaseSize(L,5);//判断余量，若不足，则申请5个新空间
    }
    for (int j = L.length; j >= i; j--)
    {
        L.data[j]=L.data[j-1];//第i个元素后的元素后移
    }
    L.data[i-1]=e;//插入
    L.length++;
    return;
}

void listDelete(SeqList &L,int i,int &e){//==删除==
    if(i<1||i>L.length){
        cout<<"删除范围无效"<<endl;//判断范围
        return;
    }
    e=L.data[i-1];//记录被删除元素值
    for (int j = i; j < L.length; j++)
    {
        L.data[j-1]=L.data[j];//第i个元素前的元素前移
    }
    L.length--;
    return;
}

void locateElem(SeqList &L,int e){//==查找==
    int i;
    for (i = 0; i < L.length; i++)
    {
        if(L.data[i]==e){
            cout<<"元素"<<e<<"是第"<<i+1<<"个"<<endl;
            return;
        }
    }
    cout<<"未查到元素"<<e<<endl;
    return;
}

void getElem(SeqList &L,int i){//==按序查找==
    if(i<1||i>L.length){
        cout<<"查找范围无效"<<endl;
        return;
    }
    cout<<"第"<<i<<"个元素为"<<L.data[i-1]<<endl;
    return;
}
int main(){
    SeqList L;
    initList(L);
    listInsert(L,1,2);
    listInsert(L,2,3);
    listInsert(L,2,5);
    printList(L);
    listInsert(L,1,1);
    printList(L);
    locateElem(L,5);
    getElem(L,2);
}
```

### 链表

链表：在物理单元上非连续，非顺序的存储结构，数据元素的逻辑顺序通过指针链接顺序实现

#### 单链表

![image-20220112145420574](image-20220112145420574.png)

每个节点由数据和后继指针两部分组成

最开始的节点叫做Head头节点，末尾节点指向NULL

