## 操作系统的发展史

（摘自[百度百科](https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8F%B2/7832586#:~:text=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B9%B6%E4%B8%8D%E6%98%AF%E4%B8%8E%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%20%E4%B8%80%E8%B5%B7%E8%AF%9E%E7%94%9F%E7%9A%84%EF%BC%8C%E5%AE%83%E6%98%AF%E5%9C%A8%E4%BA%BA%E4%BB%AC%E4%BD%BF%E7%94%A8%20%E8%AE%A1%E7%AE%97%E6%9C%BA%20%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%BB%A1%E8%B6%B3%E4%B8%A4%E5%A4%A7%E9%9C%80%E6%B1%82%EF%BC%9A%E6%8F%90%E9%AB%98%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87%E3%80%81%E5%A2%9E%E5%BC%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%EF%BC%8C%E4%BC%B4%E9%9A%8F%E7%9D%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%9C%AC%E8%BA%AB%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E7%9A%84%E6%97%A5%E7%9B%8A%E5%8F%91%E5%B1%95%EF%BC%8C%E8%80%8C%E9%80%90%E6%AD%A5%E5%9C%B0%E5%BD%A2%E6%88%90%E5%92%8C%E5%AE%8C%E5%96%84%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%82%201946%E5%B9%B4%E7%AC%AC%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%9E%E7%94%9F--20%E4%B8%96%E7%BA%AA50%E5%B9%B4%E4%BB%A3%E4%B8%AD%E6%9C%9F%EF%BC%8C%E8%BF%98%E6%9C%AA%E5%87%BA%E7%8E%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E4%BD%9C%E9%87%87%E7%94%A8%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E3%80%82,%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B0%86%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B7%B2%E7%A9%BF%E5%AD%94%E7%9A%84%E7%BA%B8%E5%B8%A6%EF%BC%88%E6%88%96%E5%8D%A1%E7%89%87%EF%BC%89%E8%A3%85%E5%85%A5%E8%BE%93%E5%85%A5%E6%9C%BA%EF%BC%8C%E7%84%B6%E5%90%8E%E5%90%AF%E5%8A%A8%E8%BE%93%E5%85%A5%E6%9C%BA%E6%8A%8A%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%EF%BC%8C%E6%8E%A5%E7%9D%80%E9%80%9A%E8%BF%87%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%BC%80%E5%85%B3%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E9%92%88%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%90%E8%A1%8C%EF%BC%9B%E8%AE%A1%E7%AE%97%E5%AE%8C%E6%AF%95%EF%BC%8C%E6%89%93%E5%8D%B0%E6%9C%BA%E8%BE%93%E5%87%BA%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C%EF%BC%9B%E7%94%A8%E6%88%B7%E5%8F%96%E8%B5%B0%E7%BB%93%E6%9E%9C%E5%B9%B6%E5%8D%B8%E4%B8%8B%E7%BA%B8%E5%B8%A6%EF%BC%88%E6%88%96%E5%8D%A1%E7%89%87%EF%BC%89%E5%90%8E%EF%BC%8C%E6%89%8D%E8%AE%A9%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E4%B8%8A%E6%9C%BA%E3%80%82%20%EF%BC%881%EF%BC%89%E7%94%A8%E6%88%B7%E7%8B%AC%E5%8D%A0%E5%85%A8%E6%9C%BA%E3%80%82%20%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%9B%A0%E8%B5%84%E6%BA%90%E5%B7%B2%E8%A2%AB%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%8D%A0%E7%94%A8%E8%80%8C%E7%AD%89%E5%BE%85%E7%9A%84%E7%8E%B0%E8%B1%A1%EF%BC%8C%E4%BD%86%E8%B5%84%E6%BA%90%E7%9A%84%E5%88%A9%E7%94%A8%E7%8E%87%E4%BD%8E%E3%80%82%20%EF%BC%882%EF%BC%89CPU%20%E7%AD%89%E5%BE%85%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C%E3%80%82%20CPU%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8D%E5%85%85%E5%88%86%E3%80%82))

#### 手工操作

    1946年第一台计算机诞生--20世纪50年代中期，还未出现操作系统，计算机工作采用手工操作方式。

<img src="https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212141762-171050924.png" title="" alt="" data-align="center">

手工操作

    程序员将对应用程序和数据的已穿孔的纸带（或卡片）装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行；计算完毕，打印机输出计算结果；用户取走结果并卸下纸带（或卡片）后，才让下一个用户上机。

手工操作方式两个特点：

（1）用户独占全机。不会出现因资源已被其他用户占用而等待的现象，但资源的利用率低。

（2）CPU 等待手工操作。CPU的利用不充分。

 20世纪50年代后期，出现[人机矛盾](https://baike.baidu.com/item/%E4%BA%BA%E6%9C%BA%E7%9F%9B%E7%9B%BE)：手工操作的慢速度和计算机的高速度之间形成了尖锐矛盾，手工操作方式已严重损害了系统资源的利用率（使资源利用率降为百分之几，甚至更低），不能容忍。唯一的解决办法：只有摆脱人的手工操作，实现作业的自动过渡。这样就出现了成[批处理](https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86)。

#### 批处理系统

    [批处理系统](https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)：加载在计算机上的一个[系统软件](https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6)，在它的控制下，计算机能够自动地、成批地处理一个或多个用户的作业（这作业包括程序、数据和命令）。

##### 联机批处理系统

首先出现的是[联机批处理系统](https://baike.baidu.com/item/%E8%81%94%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)，即作业的输入/输出由CPU来处理。

![pics](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104213136765-1264033805.png)

    主机与输入机之间增加一个存储设备——磁带，在运行于主机上的监督程序的自动控制下，计算机可自动完成：成批地把输入机上的用户作业读入磁带，依次把磁带上的用户作业读入主机内存并执行并把计算结果向输出机输出。完成了上一批作业后，监督程序又从输入机上输入另一批作业，保存在磁带上，并按上述步骤重复处理。

    监督程序不停地处理各个作业，从而实现了作业到作业的自动转接，减少了作业建立时间和手工操作时间，有效克服了[人机矛盾](https://baike.baidu.com/item/%E4%BA%BA%E6%9C%BA%E7%9F%9B%E7%9B%BE)，提高了计算机的利用率。

    但是，在作业输入和结果输出时，主机的高速CPU仍处于空闲状态，等待慢速的输入/[输出设备](https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87)完成工作： 主机处于“忙等”状态。

##### 脱机批处理系统

    为克服与缓解：高速主机与慢速外设的矛盾，提高CPU的利用率，又引入了[脱机批处理系统](https://baike.baidu.com/item/%E8%84%B1%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)，即输入/输出脱离主机控制。

![pics](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104213225319-1693970496.png)

    这种方式的显著特征是：增加一台不与[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA)直接相连而专门用于与输入/[输出设备](https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87)打交道的卫星机。

其功能是：

（1）从输入机上读取用户作业并放到输入磁带上。

（2）从输出磁带上读取执行结果并传给输出机。

    这样，主机不是直接与慢速的输入/输出设备打交道，而是与速度相对较快的[磁带机](https://baike.baidu.com/item/%E7%A3%81%E5%B8%A6%E6%9C%BA)发生关系，有效缓解了主机与设备的矛盾。主机与卫星机可并行工作，二者分工明确，可以充分发挥主机的高速计算能力。

[脱机批处理系统](https://baike.baidu.com/item/%E8%84%B1%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F):20世纪60年代应用十分广泛，它极大缓解了[人机矛盾](https://baike.baidu.com/item/%E4%BA%BA%E6%9C%BA%E7%9F%9B%E7%9B%BE)及主机与外设的矛盾。IBM-7090/7094：配备的监督程序就是脱机批处理系统，是[现代操作系统](https://baike.baidu.com/item/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)的原型。

    不足：每次主机内存中仅存放一道作业，每当它运行期间发出输入/输出（I/O）请求后，高速的CPU便处于等待低速的I/O完成状态，致使CPU空闲。

为改善CPU的利用率，又引入了[多道程序系统](https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F)。

#### 多道程序系统

##### 多道程序设计技术

所谓[多道程序设计技术](https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF)，就是指允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。

单道程序的运行过程：

![pics](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104213252112-939403649.png)

在A程序计算时，I/O空闲， A程序I/O操作时，CPU空闲（B程序也是同样）；必须A工作完成后，B才能进入内存中开始工作，两者是串行的，全部完成共需时间=T1+T2。

[多道程序](https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F)的运行过程：

![pics](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104213353605-946117327.png)

将A、B两道程序同时存放在内存中，它们在系统的控制下，可相互穿插、交替地在CPU上运行：当A程序因请求I/O操作而放弃CPU时，B程序就可占用CPU运行，这样 CPU不再空闲，而正进行A I/O操作的I/O设备也不空闲，显然，CPU和I/O设备都处于“忙”状态，大大提高了资源的利用率，从而也提高了系统的效率，A、B全部完成所需时间<<T1+T2。

[多道程序设计技术](https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF)不仅使CPU得到充分利用，同时改善[I/O设备](https://baike.baidu.com/item/I%2FO%E8%AE%BE%E5%A4%87/9688581)和内存的利用率，从而提高了整个系统的资源利用率和系统吞吐量（单位时间内处理作业（程序）的个数），最终提高了整个系统的效率。

[单处理机系统](https://baike.baidu.com/item/%E5%8D%95%E5%A4%84%E7%90%86%E6%9C%BA%E7%B3%BB%E7%BB%9F)中多道程序运行时的特点：

（1）多道：计算机内存中同时存放几道相互独立的程序；

（2）宏观上并行：同时进入系统的几道程序都处于运行过程中，即它们先后开始了各自的运行，但都未运行完毕；

（3）微观上串行：实际上，各道程序轮流地用CPU，并交替运行。

[多道程序系统](https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F)的出现，标志着操作系统渐趋成熟的阶段，先后出现了[作业调度](https://baike.baidu.com/item/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6)管理、[处理机](https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA)管理、[存储器管理](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86)、[外部设备](https://baike.baidu.com/item/%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87)管理、文件系统管理等功能。

##### 多道批处理系统

20世纪60年代中期，在前述的[批处理系统](https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)中，引入[多道程序设计技术](https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF)后形成[多道批处理系统](https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)（简称：批处理系统）。

它有两个特点：

（1）多道：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的[作业流](https://baike.baidu.com/item/%E4%BD%9C%E4%B8%9A%E6%B5%81)。

（2）成批：在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。

批处理系统的追求目标：提高系统资源利用率和系统吞吐量，以及作业流程的自动化。

[批处理系统](https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)的一个重要缺点：不提供人机交互能力，给用户使用计算机带来不便。

虽然用户独占全机资源，并且直接控制程序的运行，可以随时了解程序运行情况。但这种工作方式因独占全机造成资源效率极低。

一种新的追求目标：既能保证计算机效率，又能方便用户使用计算机。 20世纪60年代中期，计算机技术和软件技术的发展使这种追求成为可能。

#### 分时系统

由于CPU速度不断提高和采用[分时技术](https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E6%8A%80%E6%9C%AF)，一台计算机可同时连接多个用户终端，而每个用户可在自己的终端上联机使用计算机，好象自己独占机器一样。

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212407337-2123230004.png)

分时技术：把[处理机](https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA)的运行时间分成很短的[时间片](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87)，按时间片轮流把处理机分配给各[联机作业](https://baike.baidu.com/item/%E8%81%94%E6%9C%BA%E4%BD%9C%E4%B8%9A)使用。

若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的印象是，好象他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。

具有上述特征的计算机系统称为[分时系统](https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F)，它允许多个用户同时联机使用计算机。

特点：

（1）多路性。若干个用户同时使用一台计算机。微观上看是各用户轮流使用计算机；宏观上看是各用户并行工作。

（2）[交互性](https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92%E6%80%A7)。用户可根据系统对请求的响应结果，进一步向系统提出新的请求。这种能使用户与系统进行人机对话的工作方式，明显地有别于[批处理系统](https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)，因而，[分时系统](https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F)又被称为交互式系统。

（3）独立性。用户之间可以相互独立操作，互不干扰。系统保证各用户程序运行的完整性，不会发生相互混淆或破坏现象。

（4）及时性。系统可对用户的输入及时作出响应。分时系统性能的主要指标之一是响应时间，它是指：从终端发出命令到系统予以应答所需的时间。

分时系统的主要目标：对用户响应的及时性，即不至于用户等待每一个命令的处理时间过长。

分时系统可以同时接纳数十个甚至上百个用户，由于内存空间有限，往往采用对换（又称交换）方式的存储方法。即将未“轮到”的作业放入磁盘，一旦“轮到”，再将其调入内存；而时间片用完后，又将作业存回磁盘（俗称“滚进”、“滚出“法），使同一[存储区域](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F)轮流为多个用户服务。

多用户分时系统是当今[计算机操作系统](https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)中最普遍使用的一类操作系统。

#### 实时系统

虽然[多道批处理系统](https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)和[分时系统](https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F)能获得较令人满意的资源利用率和系统响应时间，但却不能满足实时控制与实时信息处理两个应用领域的需求。于是就产生了[实时系统](https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F)，即系统能够及时响应随机发生的外部事件，并在严格的时间范围内完成对该事件的处理。

实时系统在一个特定的应用中常作为一种控制设备来使用。

实时系统可分成两类：

（1）实时控制系统。当用于飞机飞行、导弹发射等的自动控制时，要求计算机能尽快处理[测量系统](https://baike.baidu.com/item/%E6%B5%8B%E9%87%8F%E7%B3%BB%E7%BB%9F)测得的数据，及时地对飞机或导弹进行控制，或将有关信息通过显示终端提供给决策人员。当用于轧钢、石化等[工业生产过程控制](https://baike.baidu.com/item/%E5%B7%A5%E4%B8%9A%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6)时，也要求计算机能及时处理由各类传感器送来的数据，然后控制相应的执行机构。

（2）实时[信息处理系统](https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)。当用于预定飞机票、查询有关航班、航线、票价等事宜时，或当用于银行系统、[情报检索系统](https://baike.baidu.com/item/%E6%83%85%E6%8A%A5%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F)时，都要求计算机能对[终端设备](https://baike.baidu.com/item/%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87)发来的服务请求及时予以正确的回答。此类对响应及时性的要求稍弱于第一类。

[实时操作系统](https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)的主要特点：

（1）及时响应。每一个信息接收、分析处理和发送的过程必须在严格的时间限制内完成。

（2）高可靠性。需采取[冗余](https://baike.baidu.com/item/%E5%86%97%E4%BD%99)措施，双机系统前后台工作，也包括必要的保密措施等。

#### 通用操作系统

操作系统的三种基本类型：多道[批处理](https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86)系统、[分时系统](https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F)、[实时系统](https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F)。

[通用操作系统](https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)：具有多种类型操作特征的操作系统。可以同时兼有多道批处理、分时、实时处理的功能，或其中两种以上的功能。

例如：实时处理+批处理=实时[批处理系统](https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)。首先保证优先处理实时任务，插空进行批处理作业。常把实时任务称为前台作业，批作业称为后台作业。

再如：分时处理+批处理=分时批处理系统。即：时间要求不强的作业放入“后台”（批处理）处理，需频繁交互的作业在“前台”（分时）处理，[处理机](https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA)优先运行“前台”作业。

从上世纪60年代中期，国际上开始研制一些大型的[通用操作系统](https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)。这些系统试图达到功能齐全、可适应各种应用范围和操作方式变化多端的环境的目标。但是，这些系统过于复杂和庞大，不仅付出了巨大的代价，且在解决其可靠性、可维护性和可理解性方面都遇到很大的困难。

相比之下，[UNIX操作系统](https://baike.baidu.com/item/UNIX%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)却是一个例外。这是一个通用的多用户分时交互型的操作系统。它首先建立的是一个精干的核心，而其功能却足以与许多大型的操作系统相媲美，在核心层以外，可以支持庞大的软件系统。它很快得到应用和推广，并不断完善，对[现代操作系统](https://baike.baidu.com/item/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)有着重大的影响。

至此，操作系统的基本概念、功能、基本结构和组成都已形成并渐趋完善。

#### 系统发展

进入20世纪80年代，[大规模集成电路](https://baike.baidu.com/item/%E5%A4%A7%E8%A7%84%E6%A8%A1%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF)工艺技术的飞跃发展，微处理机的出现和发展，掀起了计算机大发展大普及的浪潮。一方面迎来了个人计算机的时代，同时又向计算机网络、[分布式处理](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86)、巨型计算机和智能化方向发展。于是，操作系统有了进一步的发展，如：个人[计算机操作系统](https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)、[网络操作系统](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)、[分布式操作系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)等。

个人计算机操作系统

个人计算机上的操作系统是联机交互的[单用户操作系统](https://baike.baidu.com/item/%E5%8D%95%E7%94%A8%E6%88%B7%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)，它提供的联机交互功能与通用[分时系统](https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F)提供的功能很相似。

由于是个人专用，因此一些功能会简单得多。然而，由于个人计算机的应用普及，对于提供更方便友好的[用户接口](https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3)和丰富功能的文件系统的要求会愈来愈迫切。

网络操作系统

计算机网络：通过通信设施，将地理上分散的、具有自治功能的多个计算机系统互连起来，实现信息交换、资源共享、互操作和协作处理的系统。

[网络操作系统](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)：在原来各自[计算机操作系统](https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)上，按照[网络体系结构](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)的各个协议标准增加网络管理模块，其中包括：通信、资源共享、系统安全和各种[网络应用服务](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1)。

分布式操作系统

表面上看，[分布式系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)与[计算机网络系统](https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F)没有多大区别。[分布式操作系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)也是通过[通信网络](https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C)，将地理上分散的具有自治功能的[数据处理系统](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F)或计算机系统互连起来，实现信息交换和资源共享，协作完成任务。——硬件连接相同。

但有如下一些明显的区别：

（1）分布式系统要求一个统一的操作系统，实现系统操作的统一性。

（2）分布式操作系统管理分布式系统中的所有资源，它负责全系统的资源分配和调度、任务划分、信息传输和控制协调工作，并为用户提供一个统一的界面。

（3）用户通过这一界面，实现所需要的操作和使用系统资源，至于操作定在哪一台计算机上执行，或使用哪台计算机的资源，则是操作系统完成的，用户不必知道，此谓：系统的透明性。

（4）分布式系统更强调分布式计算和处理，因此对于多机合作和系统重构、坚强性和容错能力有更高的要求，希望系统有：更短的响应时间、高吞吐量和高可靠性。

## cpu,core,procesor,process和thread

#### cpu

cpu就是指插在主板槽(socket)上的芯片。通常说的cpu数并不准确，而应该是core-cpu的核心数。

##### 多个cpu和多核cpu

多cpu指主板上有多个cpu卡槽，可以插多个cpu。而多核cpu指一个cpu有多个物理core。

 ![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212033807-411023745.png)

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212034431-675058342.png)

多个cpu：core之间通过总线通信，速度慢，效率低，同时占用主板面积大。但是cpu集成度小，出错低，成本低。一般用于大型服务器。

多核cpu：core之间通过L2 cache寄存器通信，速度远高于总线。但是要求更小的工艺，造价高。主要用于家用电脑。

#### core

core核心才是cpu处理的基本单位，一个core只能同时执行一个进程/线程。多个core能同时处理多个进程/线程。

#### processor

为了提高单个core的利用率，cpu厂商提出多线程cpu的概念：

同时多线程技术(simultaneous multithreading)和超线程技术(hyper-threading)

SMT是AMD和其他厂商的称呼，HT是Intel的称呼。如此引出了如下概念：

    -virtual core:一个物理(physical)core可以有多个虚拟core，每个虚拟core和之前的物理core有相同的功能。就是说，每个虚拟core同时可以运行一个进程/线程。

    -processor:引入虚拟core之后，把执行进程/线程的基本单位叫做processor/logical processor-处理器。即一个cpu的processor数量=所有的虚拟core数量。

以Intel多线程技术为例：当Intel超线程技术处于激活状态时(在BIOS设置中Virtualization)，CPU会在每个物理内核上公开两个执行上下文，这意味着一个物理核心可以像两个逻辑内核一样，处理不同的软件线程。

也就是常说的4核8线程的来历。

#### process

进程是程序的一次执行过程，是程序在执行中分配和管理资源的基本单位。

##### 程序上下文

指程序的执行环境，程序的执行不只是需要cpu，还需要内存，显存，磁盘，io等其他资源，这些资源被保存在进程管理块PCB中。

##### 进程切换

处理器processor进行进程调度(主要用于单processor并发)的过程：读取上下文-执行程序-保护上下文

#### thread

为了适配cpu的多线程技术，把程序也由进程分出来线程。一个进程的所有线程共享cpu和程序上下文。所以就解释了，一个处理器只能同时执行一个进程：因为只能读取一个程序上下文。并且处理器的进程调度资源远大于线程切换。因为切换线程不需要重新读取上下文和保护上下文。

所以，一个8核16线程的cpu，最多可以并行执行16个线程

#### 进程和线程的关系

***联系***

线程是进程的一部分，一个进程至少含有一个线程

*区别*

根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻量级进程。

#### 顺序执行,并发和并行

先从概念上理解，多个程序的执行方式分顺序执行和同时执行。

而同时执行针对单processor有并发，多processor是并行。

以图为例：

    顺序执行：

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212034813-207629075.png)

多个任务按顺序执行，一个任务执行时，独占所有资源，其他任务必须等待其执行完才能执行。实际cpu切换线程是需要时间

    并发执行：

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212035318-1569267230.png)

单一处理器并不能真正意义上实现同时执行，它是把cpu的执行时间分成若干时间片，每个时间片执行一部分线程，但未执行完，就切换另一个线程。因为切换时间很短，达到了纳秒级，给人的感觉就是所有的任务都在执行。

    并行

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212035715-97440547.png)

可以看到，并行才能真正提高速度，而且多核处理器也可以在每个核心上并发，实现速度提高同时效率提高，只是成本也提高了。而且这里的任务区别于并发：

    并发执行只有一个处理器，只能读取一个程序上下文，所以并发执行的abc任务都是同一个进程的不同线程。

    而并行是可以同时处理多个进程的，abc任务可以是不同进程的线程。

##### 线程上下文切换

CPU通过分配时间片来执行任务，当一个任务的时间片用完，就会切换到另一个任务。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态。
    —任务从保存到再加载的过程就是一次上下文切换

切出： 一个线程被剥夺处理器的使用权而被暂停运行
切入： 一个线程被系统选中占用处理器开始或继续运行

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212036147-1756011169.png)

上下文，一般包括通用寄存器和程序计数器的内容。在切出时，操作系统会将线程的进度信息保存到内存。在切入时，操作系统需要从内存中加载线程的上下文。

##### 并发的意义

只看上面的时序图，并发和顺序的执行时间相同的，而且如果算上线程切换的时间，好像并发处理比顺序执行花销更大。讨论并发的意义要先说明两种密集作业类型：cpu密集型作业和io密集型作业。

对于cpu密集型作业，多线程任务并发执行 并不能提高效率。而且还会降低效率(相对于顺序执行)，因为频繁的切换线程会导致更大的时间开销

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212036559-1025471135.png)

而io密集型作业中，在作业占用io时，cpu可以切换另一个作业执行，从而实现效率提高。

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212036963-763091291.png)

所以，如果作业是cpu密集型，最好设计为单线程，顺序执行。如果是IO密集型，采用多线程并发操作可以大大提高cpu效率，而且IO越密集，效率越高。

#### 查看cpu的信息

![](https://img2023.cnblogs.com/blog/2629720/202301/2629720-20230104212037470-950276187.png)

查看得知本机有一个cpu插槽,该cpu有8个物理core，每个core两个logical processor,共16个processor

#### x86 与 x86_64

##### x86

泛指一系列基于 Intel 8086 且向后兼容的中央处理器指令集架构。

x86 的 32 位架构一般又被称作 IA-32，全名为 “Intel Architecture, 32-bit”。

值得注意的是，Intel 也推出过 IA-64 架构，虽然名字上与 “IA-32” 相似，但两者完全不兼容，并不属于x86指令集架构家族。

##### x86-64

又称 x64，即英文词 64-bit extended，64 位拓展 的简写，是 x86 架构的 64 位拓展，向后兼容于 16 位及 32 位的 x86 架构。

不同厂商有不同的称呼：

- x64 于 1999 年由 AMD 设计，AMD 首次公开 64 位集以扩展给 x86，称为 “AMD64”
- 其后也为 Intel 所采用，Intel 称为 “Intel 64”
- 苹果公司和 RPM 包管理员称为 “x86-64” 或 “x86_64”
- 甲骨文公司及 Microsoft 称为 “x64”
- BSD 家族及其他 Linux 发行版则使用 “amd64”，32 位版本则称为 “i386”（或 i486/586/686）
- Arch Linux 称为 x86_64

## 进程同步

参考:[CSDN](https://blog.csdn.net/sermonlizhi/article/details/119234232)

### 几个概念

- 并发：指单个cpu同时处理多个任务，因为cpu执行速度特别快，可以来回切换不同进程，每个进程都分成多个部分执行。

并发进程之间分为独立关系和交互关系。独立关系的进程分别在自己的变量集合上运行，互不影响。

但交互关系的并发进程在执行过程中需要共享或交换数据，因此会产生竞争和协作关系。

- 竞争：多个进程读写某些共享数据时，最终执行的结果取决于运行的时序，而不是安排的顺序，这样的情况称为竞争条件。

如两个进程A、B都要使用打印机，使用打印机需要三个步骤，先取到打印机的状态，如果状态是闲置，就放文件上去，最后打印。

现先让A取得打印机的状态，A获取状态为“闲置”，但是此时A的CPU时间片用完，切换到B进程，也识别到打印机为闲置状态，B将要打印的文件b放在打印机上，但CPU时间片也用完了。

接着切换到进程A，因为它已经获取了状态为闲置，所以A直接将a文件放上去，把b覆盖了。然后打印出文件a，而文件b打印不出来了。

- 同步和异步：并发执行的进程中，如果相互之间没有竞争关系，就用异步方式执行，异步方式，也就是按随机时序执行，因为没有竞争，就没有冲突，先执行谁无所谓。
  
  - 而对于有竞争关系的进程，则需要用同步方式执行，规定一个cpu时间只有一个进城在执行，其他有竞争关系的进程都是被阻塞的状态。
  
  - 所以异步效率更高，因为不会有进程被阻塞，但为了程序的稳定，必须对竞争关系的进程做同步处理。

- 进程同步和进程互斥：

同步和互斥就是进程之间的两种关系，也对应并发中竞争与协作。

- 共享数据：指并发进程中不同进程会使用的相同资源
  
  - 资源共享的方式：
    
    - 互斥共享：一个时间段内只允许一个进程访问
    
    - 同时共享：一个时间段内允许多个进程访问

- 临界资源：指共享数据中一次只能被一个进程使用的资源，如打印机，就是上面互斥共享的资源

- 临界区：访问临街资源的代码段

- 对临界区的互斥访问在逻辑上分为4个部分：

```cpp
do{
    entry section;//进入区
    critical section;//临界区
    exit section;//退出区
    reminder section;//剩余区
}
```

- 互斥访问的原则：
  
  - 空闲让进
  
  - 忙则等待
  
  - 有限等待

对请求访问的进程，应保证能在有限时间内进入临界区。

- 让权等待
  
  当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

- 进入区和退出区是负责实现互斥的代码，常用的机制有：
  
  - 互斥锁/量(mutex)：上锁(lock)和解锁(unlock)
  
  - 信号量(semaphore)：最大许可数、P(wait)、V(signal)

##### 互斥量和信号量

- 互斥量：也称为互斥锁，mutex lock，是操作系统设计人员解决临街区问题的最简单的工具。互斥锁是通过硬件方案实现互斥的，互斥锁需要通过执行TSL(test and lock,测试并加锁)指令来获取锁，TSL是一个原子操作，由CPU保证原子性。执行TSL指令时，CPU通过硬件锁住内存总线，其他CPU将无法访问内存，直到TSL指令执行完。
  
  - lock原理：为了使用TSL指令，需要一个共享变量lock来协调对共享内存的访问，当lock为0时，任何进程都可以使用TSL指令，并将其置一。操作结束后，使用mov指令将lock重新置零。

```asm6502
enter_regional:
    //复制锁到寄存器并将锁设为1,为什么直接设置为1呢？
    //只有TSL指令是原子操作,如果原来就是1,再设置成1没什么问题;如果原来是0,设置成1,防止TSL指令执行       //完之后,其他进程来更改LOCK的值,能保证当前进程正确进入临界区
    TSL REGISTER,LOCK   
    //判断锁是否为0
    CMP REGISTER,#0
    //若不是0,说明锁已经被设置,所以循环等待
    JNE enter_regional
    RET

leave_regional:
    MOV LOCK,#0    //在锁中存入0,表示该锁空闲
    RET                //返回调用者
```

通过上面的指令可以看出，当一个进程想要获得lock锁，而lock又被其他进程占用时，只能空循环等待，这种等待方式被称为忙式等待。

- - 忙式等待：占用CPU执行空循环实现等待

这种类型的互斥锁也被成为自旋锁

自旋锁的优点：进程在等待时没有上下文切换，对于使用锁时间不长的进程，自旋锁还是可以接受的。

缺点：浪费CPU周期，解决方案：可以将进程插入等待队列让出CPU的使用权，而不是占用CPU空循环等待。

- 信号量：信号量是一种比互斥锁更强大的**同步**工具。定义信号量S是一个整数，除了初始化之外，只能通过两个标准的原子操作P和V访问。

P：wait() operation 等待操作

V：signal() operation 信号操作

- - 信号量的实现：

```cpp
P(s){
    while(s <= 0)
        do nothing;
    s --;
}

V(s){
    s ++;
}
```

上面的代码演示了信号量P/V操作的原理，其中S为信号量，对信号量进行P操作时，首先测试信号量s是否小于等于0，如果小于等于0，则进行忙式等待（空循环等待），对应while与do nothing。如果大于0,也就是没有到达资源上限，就将信号量减一，意味着资源分配了出去。

而对于V操作，只是简单的把信号值加一，相当于回收资源，不需要考虑其他因素

- - 信号量的使用：
1. 二值信号量：binary semaphore ，信号量只有一个二进制位，只表示0/1,一般用1表示，符合常规，用来实现互斥锁的功能。如：

```cpp
semaphore mutex = 1;
process pi{
    P(mutex);

    critical section

    V(mutex);
}
```

但明显二值信号量和互斥锁是不同的，从实现方式和原子性就可以区别。大部分的信号量S是大于1的，用来实现资源共享：

2. 一般信号量：counting semaphore: 信号量S一般为大于1的整数，用来表示共享资源的数量。如一个Y字型岔路的程序：

```cpp
semaphore road = 2;
process Car{
    P(road);

    pass the fork
    in the road

    V(road);
}
```

每条路一次只有一辆车单向行驶，用PV操作来表示车辆驶入和驶离。

3. 信号量实现同步：当信号量S=0时，用来解决进程之间的同步问题。

同步问题的实质就是将异步并发的进程按照某种顺序执行，以达到期望的结果。

而解决同步问题的本质，就是找到并发进程的交互点，利用信号量P操作自旋等待的特点来调节进程的执行速度。

所以，将同步信号量设置为0,可以让进程直接进入等待状态，直到另一个进程唤醒它。如：

公交车司机和售票员的问题，只有当公交车关门的时候，车才能启动，只有当车停下的时候，车门才能打开。

```cpp
semaphore_d = 0;
semaphore_c = 0;

司机               售票员
P(semaphore_d)   关车门
车启动            V(semaphore_d)
行驶中            售车票
                 P(semaphore_c)
车停下            开车门
V(semaphore_c)
```

###### 经典同步问题
